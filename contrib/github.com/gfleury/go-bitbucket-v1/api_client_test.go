/*
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package bitbucketv1

import (
	"bytes"
	"mime/multipart"
	"net/http"
	"net/url"
	"reflect"
	"testing"
	"time"

	"golang.org/x/net/context"
)

func TestNewAPIClient(t *testing.T) {
	type args struct {
		ctx context.Context
		cfg *Configuration
	}
	tests := []struct {
		name string
		args args
		want *APIClient
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := NewAPIClient(tt.args.ctx, tt.args.cfg); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("NewAPIClient() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_atoi(t *testing.T) {
	type args struct {
		in string
	}
	tests := []struct {
		name    string
		args    args
		want    int
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := atoi(tt.args.in)
			if (err != nil) != tt.wantErr {
				t.Errorf("atoi() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != tt.want {
				t.Errorf("atoi() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_selectHeaderContentType(t *testing.T) {
	type args struct {
		contentTypes []string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := selectHeaderContentType(tt.args.contentTypes); got != tt.want {
				t.Errorf("selectHeaderContentType() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_selectHeaderAccept(t *testing.T) {
	type args struct {
		accepts []string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := selectHeaderAccept(tt.args.accepts); got != tt.want {
				t.Errorf("selectHeaderAccept() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_contains(t *testing.T) {
	type args struct {
		haystack []string
		needle   string
	}
	tests := []struct {
		name string
		args args
		want bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := contains(tt.args.haystack, tt.args.needle); got != tt.want {
				t.Errorf("contains() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_typeCheckParameter(t *testing.T) {
	type args struct {
		obj      interface{}
		expected string
		name     string
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := typeCheckParameter(tt.args.obj, tt.args.expected, tt.args.name); (err != nil) != tt.wantErr {
				t.Errorf("typeCheckParameter() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_parameterToString(t *testing.T) {
	type args struct {
		obj              interface{}
		collectionFormat string
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := parameterToString(tt.args.obj, tt.args.collectionFormat); got != tt.want {
				t.Errorf("parameterToString() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestAPIClient_callAPI(t *testing.T) {
	type fields struct {
		cfg        *Configuration
		common     service
		ctx        context.Context
		DefaultApi *DefaultApiService
	}
	type args struct {
		request *http.Request
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    *http.Response
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &APIClient{
				cfg:        tt.fields.cfg,
				common:     tt.fields.common,
				ctx:        tt.fields.ctx,
				DefaultApi: tt.fields.DefaultApi,
			}
			got, err := c.callAPI(tt.args.request)
			if (err != nil) != tt.wantErr {
				t.Errorf("APIClient.callAPI() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("APIClient.callAPI() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestAPIClient_ChangeBasePath(t *testing.T) {
	type fields struct {
		cfg        *Configuration
		common     service
		ctx        context.Context
		DefaultApi *DefaultApiService
	}
	type args struct {
		path string
	}
	tests := []struct {
		name   string
		fields fields
		args   args
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &APIClient{
				cfg:        tt.fields.cfg,
				common:     tt.fields.common,
				ctx:        tt.fields.ctx,
				DefaultApi: tt.fields.DefaultApi,
			}
			c.ChangeBasePath(tt.args.path)
		})
	}
}

func TestAPIClient_prepareRequest(t *testing.T) {
	type fields struct {
		cfg        *Configuration
		common     service
		ctx        context.Context
		DefaultApi *DefaultApiService
	}
	type args struct {
		ctx          context.Context
		path         string
		method       string
		postBody     interface{}
		headerParams map[string]string
		queryParams  url.Values
		formParams   url.Values
		fileName     string
		fileBytes    []byte
	}
	tests := []struct {
		name                string
		fields              fields
		args                args
		wantLocalVarRequest *http.Request
		wantErr             bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			c := &APIClient{
				cfg:        tt.fields.cfg,
				common:     tt.fields.common,
				ctx:        tt.fields.ctx,
				DefaultApi: tt.fields.DefaultApi,
			}
			gotLocalVarRequest, err := c.prepareRequest(tt.args.ctx, tt.args.path, tt.args.method, tt.args.postBody, tt.args.headerParams, tt.args.queryParams, tt.args.formParams, tt.args.fileName, tt.args.fileBytes)
			if (err != nil) != tt.wantErr {
				t.Errorf("APIClient.prepareRequest() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(gotLocalVarRequest, tt.wantLocalVarRequest) {
				t.Errorf("APIClient.prepareRequest() = %v, want %v", gotLocalVarRequest, tt.wantLocalVarRequest)
			}
		})
	}
}

func Test_addFile(t *testing.T) {
	type args struct {
		w         *multipart.Writer
		fieldName string
		path      string
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := addFile(tt.args.w, tt.args.fieldName, tt.args.path); (err != nil) != tt.wantErr {
				t.Errorf("addFile() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_reportError(t *testing.T) {
	type args struct {
		format string
		a      []interface{}
	}
	tests := []struct {
		name    string
		args    args
		wantErr bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if err := reportError(tt.args.format, tt.args.a...); (err != nil) != tt.wantErr {
				t.Errorf("reportError() error = %v, wantErr %v", err, tt.wantErr)
			}
		})
	}
}

func Test_setBody(t *testing.T) {
	type args struct {
		body        interface{}
		contentType string
	}
	tests := []struct {
		name        string
		args        args
		wantBodyBuf *bytes.Buffer
		wantErr     bool
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotBodyBuf, err := setBody(tt.args.body, tt.args.contentType)
			if (err != nil) != tt.wantErr {
				t.Errorf("setBody() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(gotBodyBuf, tt.wantBodyBuf) {
				t.Errorf("setBody() = %v, want %v", gotBodyBuf, tt.wantBodyBuf)
			}
		})
	}
}

func Test_detectContentType(t *testing.T) {
	type args struct {
		body interface{}
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := detectContentType(tt.args.body); got != tt.want {
				t.Errorf("detectContentType() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_parseCacheControl(t *testing.T) {
	type args struct {
		headers http.Header
	}
	tests := []struct {
		name string
		args args
		want cacheControl
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := parseCacheControl(tt.args.headers); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("parseCacheControl() = %v, want %v", got, tt.want)
			}
		})
	}
}

func TestCacheExpires(t *testing.T) {
	type args struct {
		r *http.Response
	}
	tests := []struct {
		name string
		args args
		want time.Time
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := CacheExpires(tt.args.r); !reflect.DeepEqual(got, tt.want) {
				t.Errorf("CacheExpires() = %v, want %v", got, tt.want)
			}
		})
	}
}

func Test_strlen(t *testing.T) {
	type args struct {
		s string
	}
	tests := []struct {
		name string
		args args
		want int
	}{
		// TODO: Add test cases.
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := strlen(tt.args.s); got != tt.want {
				t.Errorf("strlen() = %v, want %v", got, tt.want)
			}
		})
	}
}
